#include <vector>
#include <queue>
#include <tuple>
#include <algorithm>

using namespace std;

class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        if (heightMap.empty() || heightMap[0].empty()) {
            return 0;
        }

        int m = heightMap.size();
        int n = heightMap[0].size();
        
        
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> minHeap;
        
        
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        
        
        
       
        for (int i = 0; i < m; ++i) {
            
            minHeap.emplace(heightMap[i][0], i, 0);
            visited[i][0] = true;
            
            
            if (n - 1 != 0) {
                minHeap.emplace(heightMap[i][n - 1], i, n - 1);
                visited[i][n - 1] = true;
            }
        }

        
        for (int j = 1; j < n - 1; ++j) {
            
            minHeap.emplace(heightMap[0][j], 0, j);
            visited[0][j] = true;
            
           
            if (m - 1 != 0) {
                minHeap.emplace(heightMap[m - 1][j], m - 1, j);
                visited[m - 1][j] = true;
            }
        }

        int trappedWater = 0;
        
        int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!minHeap.empty()) {
            auto [h, r, c] = minHeap.top(); 
            minHeap.pop();

            
            for (int i = 0; i < 4; ++i) {
                int nr = r + directions[i][0]; 
                int nc = c + directions[i][1]; 

                // Ch
                if (nr > 0 && nr < m - 1 && nc > 0 && nc < n - 1 && !visited[nr][nc]) {
                    
                    visited[nr][nc] = true;

                    if (heightMap[nr][nc] < h) {
                        trappedWater += h - heightMap[nr][nc];
                        minHeap.emplace(h, nr, nc);
                    } else {
                        
                        minHeap.emplace(heightMap[nr][nc], nr, nc);
                    }
                }
            }
        }

        return trappedWater;
    }
};
